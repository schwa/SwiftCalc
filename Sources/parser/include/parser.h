// This file was generated by the Owl parsing tool.
// Make sure to #define OWL_PARSER_IMPLEMENTATION somewhere so the parser
// is compiled properly.  Just two lines are enough -- a typical parser.c might
// look like:
//
//   #define OWL_PARSER_IMPLEMENTATION
//   #include "parser.h"

#ifndef OWL_PARSER_H
#define OWL_PARSER_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>

// The owl_tree struct represents an entire parse tree.  Use the
// owl_tree_create_...() functions to create a tree, then call owl_tree_root()
// to get the root owl_ref.
struct owl_tree;

// Creates an owl_tree from a string.  The tree may directly reference pieces of
// the string -- you're responsible for keeping it around until
// owl_tree_destroy() is called.
struct owl_tree *owl_tree_create_from_string(const char *string);

// Creates an owl_tree by reading from a file.
struct owl_tree *owl_tree_create_from_file(FILE *file);

// Explicitly create a tree with particular options.
struct owl_tree_options {
    // Exactly one of string or file should be set.
    const char *string;
    FILE *file;
};
struct owl_tree *owl_tree_create_with_options(struct owl_tree_options options);

// Destroys an owl_tree, freeing its resources back to the system.
void owl_tree_destroy(struct owl_tree *);

// Prints a representation of the tree to standard output.
void owl_tree_print(struct owl_tree *);

// An owl_ref references a list of children in the parse tree.  Use the
// parsed_..._get() function corresponding to the element type to unpack the
// child into its appropriate parsed_... struct.
struct owl_ref {
    struct owl_tree *_tree;
    size_t _offset;
    uint32_t _type;
    bool empty;
};

// The owl_next function advances a ref to the next sibling element.
struct owl_ref owl_next(struct owl_ref);

// Tests two refs for equality.
bool owl_refs_equal(struct owl_ref a, struct owl_ref b);

// Returns the root owl_ref.
struct owl_ref owl_tree_root_ref(struct owl_tree *tree);

// As a shortcut, returns the parsed_expression struct corresponding to the root ref.
struct parsed_expression owl_tree_get_parsed_expression(struct owl_tree *tree);

// The range of text corresponding to a tree element.
struct source_range {
    size_t start;
    size_t end;
};

enum owl_error {
    // No error -- everything's fine!
    ERROR_NONE,

    // The file passed to owl_tree_create_from_file was NULL.
    ERROR_INVALID_FILE,

    // The options passed to owl_tree_create_with_options weren't valid --
    // both file and string were specified at the same time or neither were.
    ERROR_INVALID_OPTIONS,

    // A piece of text couldn't be matched as a token.
    ERROR_INVALID_TOKEN,

    // The parser encountered an out-of-place token that doesn't fit the grammar.
    ERROR_UNEXPECTED_TOKEN,

    // The input is valid so far, but incomplete; more tokens could be added to
    // complete it.
    ERROR_MORE_INPUT_NEEDED,
};
// Returns an error code, or ERROR_NONE if there wasn't an error.
// The error_range parameter can be null.
enum owl_error owl_tree_get_error(struct owl_tree *tree, struct source_range *error_range);

enum parsed_type {
    PARSED_ADD = 1,
    PARSED_CALL,
    PARSED_DIVIDE,
    PARSED_NEGATE,
    PARSED_NUMBER,
    PARSED_PARENS,
    PARSED_MULTIPLY,
    PARSED_SUBTRACT,
    PARSED_VARIABLE,
};

struct parsed_expression {
    struct source_range range;
    enum parsed_type type;
    struct owl_ref identifier;
    struct owl_ref number;
    struct owl_ref expression;
    struct owl_ref operand;
    struct owl_ref left;
    struct owl_ref right;
};

struct parsed_identifier {
    struct source_range range;
    const char *identifier;
    size_t length;
};

struct parsed_number {
    struct source_range range;
    double number;
};

struct parsed_expression parsed_expression_get(struct owl_ref);
struct parsed_identifier parsed_identifier_get(struct owl_ref);
struct parsed_number parsed_number_get(struct owl_ref);

#endif

#ifdef OWL_PARSER_IMPLEMENTATION
// Code implementing the parser.  This might get a bit messy!
#include <assert.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if defined(__clang__) || defined(__GNUC__)
#define OWL_DONT_INLINE __attribute__((noinline))
#else
#define OWL_DONT_INLINE
#endif

struct owl_tree {
    const char *string;
    bool owns_string;
    uint8_t *parse_tree;
    size_t parse_tree_size;
    size_t next_offset;
    enum owl_error error;
    struct source_range error_range;
    size_t root_offset;
    size_t next_identifier_token_offset;
    size_t next_number_token_offset;
};
// Reserve 10 bytes for each entry (the maximum encoded size of a 64-bit value).
#define RESERVATION_AMOUNT 10
static inline uint64_t read_tree(size_t *offset, struct owl_tree *tree) {
    uint8_t *parse_tree = tree->parse_tree;
    size_t parse_tree_size = tree->parse_tree_size;
    size_t i = *offset;
    if (i + RESERVATION_AMOUNT >= parse_tree_size)
        return 0;
    uint64_t result = 0;
    int shift_amount = 0;
    while ((parse_tree[i] & 0x80) != 0 && shift_amount < 64) {
        result |= ((uint64_t)parse_tree[i] & 0x7f) << shift_amount;
        shift_amount += 7;
        i++;
    }
    result |= ((uint64_t)parse_tree[i] & 0x7f) << shift_amount;
    i++;
    *offset = i;
    return result;
}
static bool grow_tree(struct owl_tree *tree, size_t size)
{
    size_t n = tree->parse_tree_size;
    while (n < size || n < 4096)
        n = (n + 1) * 3 / 2;
    uint8_t *parse_tree = realloc(tree->parse_tree, n);
    if (!parse_tree)
        return false;
    tree->parse_tree_size = n;
    tree->parse_tree = parse_tree;
    return true;
}
static void write_tree(struct owl_tree *tree, uint64_t value)
{
    size_t reserved_size = tree->next_offset + RESERVATION_AMOUNT;
    if (tree->parse_tree_size <= reserved_size && !grow_tree(tree, reserved_size))
        abort();
    while (value >> 7 != 0) {
        tree->parse_tree[tree->next_offset++] = 0x80 | (value & 0x7f);
        value >>= 7;
    }
    tree->parse_tree[tree->next_offset++] = value & 0x7f;
}
struct parsed_expression parsed_expression_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 0) {
        return (struct parsed_expression){
            .identifier.empty = true,
            .number.empty = true,
            .expression.empty = true,
            .operand.empty = true,
            .left.empty = true,
            .right.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_expression result = {
        .range.start = start_location,
        .range.end = end_location,
        .type = (enum parsed_type)read_tree(&offset, ref._tree),
    };
    result.identifier._tree = ref._tree;
    result.identifier._offset = read_tree(&offset, ref._tree);
    result.identifier._type = 1;
    result.identifier.empty = result.identifier._offset == 0;
    result.number._tree = ref._tree;
    result.number._offset = read_tree(&offset, ref._tree);
    result.number._type = 2;
    result.number.empty = result.number._offset == 0;
    result.expression._tree = ref._tree;
    result.expression._offset = read_tree(&offset, ref._tree);
    result.expression._type = 0;
    result.expression.empty = result.expression._offset == 0;
    result.operand._tree = ref._tree;
    result.operand._offset = read_tree(&offset, ref._tree);
    result.operand._type = 0;
    result.operand.empty = result.operand._offset == 0;
    result.left._tree = ref._tree;
    result.left._offset = read_tree(&offset, ref._tree);
    result.left._type = 0;
    result.left.empty = result.left._offset == 0;
    result.right._tree = ref._tree;
    result.right._offset = read_tree(&offset, ref._tree);
    result.right._type = 0;
    result.right.empty = result.right._offset == 0;
    return result;
}
struct parsed_identifier parsed_identifier_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 1) {
        return (struct parsed_identifier){
            {0}
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t token_offset = read_tree(&offset, ref._tree);
    read_tree(&token_offset, ref._tree);
    size_t start_location = read_tree(&token_offset, ref._tree);
    size_t end_location = start_location + read_tree(&token_offset, ref._tree);
    struct parsed_identifier result = {
        .range.start = start_location,
        .range.end = end_location,
        .identifier = ref._tree->string + start_location,
        .length = end_location - start_location,
    };
    return result;
}
struct parsed_number parsed_number_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 2) {
        return (struct parsed_number){
            {0}
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t token_offset = read_tree(&offset, ref._tree);
    read_tree(&token_offset, ref._tree);
    size_t start_location = read_tree(&token_offset, ref._tree);
    size_t end_location = start_location + read_tree(&token_offset, ref._tree);
    struct parsed_number result = {
        .range.start = start_location,
        .range.end = end_location,
        .number = (union { double n; uint64_t v; }){ .v = read_tree(&token_offset, ref._tree) }.n,
    };
    return result;
}
static size_t finish_node(uint32_t rule, uint32_t choice, size_t next_sibling, size_t *slots, size_t start_location, size_t end_location, void *info) {
    struct owl_tree *tree = info;
    size_t offset = tree->next_offset;
    write_tree(tree, next_sibling ? offset - next_sibling : 0);
    write_tree(tree, start_location);
    write_tree(tree, end_location - start_location);
    switch (rule) {
    case 0: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_VARIABLE);
            break;
        case 1:
            write_tree(tree, PARSED_NUMBER);
            break;
        case 2:
            write_tree(tree, PARSED_PARENS);
            break;
        case 3:
            write_tree(tree, PARSED_CALL);
            break;
        case 4:
            write_tree(tree, PARSED_NEGATE);
            break;
        case 5:
            write_tree(tree, PARSED_MULTIPLY);
            break;
        case 6:
            write_tree(tree, PARSED_DIVIDE);
            break;
        case 7:
            write_tree(tree, PARSED_ADD);
            break;
        case 8:
            write_tree(tree, PARSED_SUBTRACT);
            break;
        }
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        write_tree(tree, slots[2]);
        write_tree(tree, slots[3]);
        write_tree(tree, slots[4]);
        write_tree(tree, slots[5]);
        break;
    }
    default:
        break;
    }
    return offset;
}
static size_t finish_token(uint32_t rule, size_t next_sibling, void *info) {
    struct owl_tree *tree = info;
    size_t offset = tree->next_offset;
    write_tree(tree, next_sibling ? offset - next_sibling : 0);
    switch (rule) {
    case 1: {
        size_t offset1 = tree->next_identifier_token_offset;
        if (offset1 == 0)
            abort();
        write_tree(tree, offset1);
        tree->next_identifier_token_offset = offset1;
        tree->next_identifier_token_offset -= read_tree(&offset1, tree);
        break;
    }
    case 2: {
        size_t offset2 = tree->next_number_token_offset;
        if (offset2 == 0)
            abort();
        write_tree(tree, offset2);
        tree->next_number_token_offset = offset2;
        tree->next_number_token_offset -= read_tree(&offset2, tree);
        break;
    }
    default:
        break;
    }
    return offset;
}
static void check_for_error(struct owl_tree *tree) {
    if (tree->error == ERROR_NONE)
        return;
    fprintf(stderr, "parse error: ");
    switch (tree->error) {
    case ERROR_INVALID_FILE:
        fprintf(stderr, "invalid file\n");
        break;
    case ERROR_INVALID_OPTIONS:
        fprintf(stderr, "invalid options\n");
        break;
    case ERROR_INVALID_TOKEN:
        fprintf(stderr, "invalid token '%.*s'\n", (int)(tree->error_range.end - tree->error_range.start), tree->string + tree->error_range.start);
        break;
    case ERROR_UNEXPECTED_TOKEN:
        fprintf(stderr, "unexpected token '%.*s'\n", (int)(tree->error_range.end - tree->error_range.start), tree->string + tree->error_range.start);
        break;
    case ERROR_MORE_INPUT_NEEDED:
        fprintf(stderr, "more input needed\n");
        break;
    default:
        break;
    }
    exit(-1);
}
static void parsed_expression_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_identifier_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_number_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_expression_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    int i;
    while (!ref.empty) {
        struct parsed_expression it = parsed_expression_get(ref);
        for (i = 0; i < indent; ++i) printf("  ");
        printf("expression");
        if (strcmp("expression", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_VARIABLE:
            printf(" : VARIABLE");
            break;
        case PARSED_NUMBER:
            printf(" : NUMBER");
            break;
        case PARSED_PARENS:
            printf(" : PARENS");
            break;
        case PARSED_CALL:
            printf(" : CALL");
            break;
        case PARSED_NEGATE:
            printf(" : NEGATE");
            break;
        case PARSED_MULTIPLY:
            printf(" : MULTIPLY");
            break;
        case PARSED_DIVIDE:
            printf(" : DIVIDE");
            break;
        case PARSED_ADD:
            printf(" : ADD");
            break;
        case PARSED_SUBTRACT:
            printf(" : SUBTRACT");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_number_print(tree, it.number, "number", indent + 1);
        parsed_expression_print(tree, it.expression, "expression", indent + 1);
        parsed_expression_print(tree, it.operand, "operand", indent + 1);
        parsed_expression_print(tree, it.left, "left", indent + 1);
        parsed_expression_print(tree, it.right, "right", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_identifier_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    int i;
    while (!ref.empty) {
        struct parsed_identifier it = parsed_identifier_get(ref);
        for (i = 0; i < indent; ++i) printf("  ");
        printf("identifier");
        if (strcmp("identifier", slot_name))
            printf("@%s", slot_name);
        printf(" - %.*s", (int)it.length, it.identifier);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        ref = owl_next(ref);
    }
}
static void parsed_number_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    int i;
    while (!ref.empty) {
        struct parsed_number it = parsed_number_get(ref);
        for (i = 0; i < indent; ++i) printf("  ");
        printf("number");
        if (strcmp("number", slot_name))
            printf("@%s", slot_name);
        printf(" - %f", it.number);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        ref = owl_next(ref);
    }
}
void owl_tree_print(struct owl_tree *tree) {
    check_for_error(tree);
    parsed_expression_print(tree, owl_tree_root_ref(tree), "expression", 0);
}
struct owl_ref owl_next(struct owl_ref ref) {
    if (ref.empty) return ref;
    size_t offset = ref._offset;
    size_t delta = read_tree(&ref._offset, ref._tree);
    return (struct owl_ref){
        ._tree = ref._tree,
        ._offset = offset - delta,
        ._type = ref._type,
        .empty = delta == 0,
    };
}
bool owl_refs_equal(struct owl_ref a, struct owl_ref b) {
    return a._tree == b._tree && a._offset == b._offset;
}
struct owl_ref owl_tree_root_ref(struct owl_tree *tree) {
    check_for_error(tree);
    return (struct owl_ref){
        ._tree = tree,
        ._offset = tree->root_offset,
        ._type = 0,
        .empty = tree->root_offset == 0,
    };
}
struct parsed_expression owl_tree_get_parsed_expression(struct owl_tree *tree) {
    check_for_error(tree);
    return parsed_expression_get(owl_tree_root_ref(tree));
}
#define ESCAPE_CHAR(c, info) ((c) == 'b' ? '\b' : (c) == 'f' ? '\f' : (c) == 'n' ? '\n' : (c) == 'r' ? '\r' : (c) == 't' ? '\t' : (c))
#define IGNORE_TOKEN_WRITE(...)
#define IGNORE_TOKEN_READ(...) (0)
#define CUSTOM_TOKEN_DATA(...)
#define IF_IDENTIFIER_TOKEN(cond, ...) if (cond) __VA_ARGS__
#define INTEGER_TOKEN_DATA(...)
#define IF_INTEGER_TOKEN(...) if (0) { /* no integer tokens */  }
#define NUMBER_TOKEN_DATA(name) double name = 0
#define IF_NUMBER_TOKEN(cond, ...) if (cond) __VA_ARGS__
#define IF_STRING_TOKEN(...) if (0) { /* no string tokens */  }
static size_t read_whitespace(const char *text, void *info);
static size_t read_keyword_token(uint32_t *token, bool *end_token, const char *text, void *info);
static void write_identifier_token(size_t offset, size_t length, void *info) {
    struct owl_tree *tree = info;
    size_t token_offset = tree->next_offset;
    write_tree(tree, token_offset - tree->next_identifier_token_offset);
    write_tree(tree, offset);
    write_tree(tree, length);
    tree->next_identifier_token_offset = token_offset;
}
static void write_number_token(size_t offset, size_t length, double number, void *info) {
    struct owl_tree *tree = info;
    size_t token_offset = tree->next_offset;
    write_tree(tree, token_offset - tree->next_number_token_offset);
    write_tree(tree, offset);
    write_tree(tree, length);
    union { double n; uint64_t v; } u = { .n = number };
    write_tree(tree, u.v);
    tree->next_number_token_offset = token_offset;
}
static void *allocate_string_contents(size_t size, void *info) {
    struct owl_tree *tree = info;
    if (tree->next_offset + size > tree->parse_tree_size)
        grow_tree(tree, tree->next_offset + size);
    void *p = tree->parse_tree + tree->next_offset;
    tree->next_offset += size;
    return p;
}
struct owl_token_run {
    struct owl_token_run *prev;
    uint16_t number_of_tokens;
    uint16_t lengths_size;
    uint8_t lengths[4096 * 2];
    uint32_t tokens[4096];
    uint32_t states[4096];
};
struct owl_default_tokenizer {
    const char *text;
    size_t offset;
    size_t whitespace;
    uint32_t identifier_token;
    uint32_t number_token;
    uint32_t string_token;
    void *info;
};
static bool char_is_whitespace(char c) {
    switch (c) {
    case ' ':
    case '\t':
    case '\r':
    case '\n':
        return true;
    default:
        return false;
    }
}
static bool char_is_numeric(char c) {
    return c >= '0' && c <= '9';
}
static bool char_is_alphabetic(char c) {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}
static bool char_is_hexadecimal_alpha(char c) {
    return (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}
static bool char_starts_identifier(char c) {
    return char_is_alphabetic(c) || c == '_';
}
static bool char_continues_identifier(char c, void *info) {
    if (false && c == '-') return true;
    return char_is_numeric(c) || char_starts_identifier(c);
}
static bool char_ends_identifier(char c) {
    return c != '-';
}
static bool encode_length(struct owl_token_run *run, uint16_t *lengths_size, size_t length) {
    uint8_t mark = 0;
    while (*lengths_size < sizeof(run->lengths)) {
        run->lengths[*lengths_size] = mark | (length & 0x7f);
        mark = 0x80;
        length >>= 7;
        (*lengths_size)++;
        if (length == 0) return true;
    }
    return false;
}
static bool encode_token_length(struct owl_token_run *run, uint16_t *lengths_size, size_t length, size_t whitespace) {
    uint16_t size = *lengths_size;
    if (encode_length(run, lengths_size, length) && encode_length(run, lengths_size, whitespace)) return true;
    *lengths_size = size;
    return false;
}
static size_t decode_length(struct owl_token_run *run, uint16_t *length_offset) {
    size_t length = 0;
    while (*length_offset < sizeof(run->lengths)) {
        size_t l = run->lengths[(*length_offset)--];
        length <<= 7;
        length += l & 0x7f;
        if (!(l & 0x80)) return length;
    }
    abort();
}
static size_t decode_token_length(struct owl_token_run *run, uint16_t *length_offset, size_t *string_offset) {
    size_t whitespace = decode_length(run, length_offset);
    size_t length = decode_length(run, length_offset);
    *string_offset -= whitespace + length;
    return length;
}
static bool OWL_DONT_INLINE owl_default_tokenizer_advance(struct owl_default_tokenizer *tokenizer, struct owl_token_run **previous_run) {
    struct owl_token_run *run = malloc(sizeof(struct owl_token_run));
    if (!run) return false;
    uint16_t number_of_tokens = 0;
    uint16_t lengths_size = 0;
    const char *text = tokenizer->text;
    size_t whitespace = tokenizer->whitespace;
    size_t offset = tokenizer->offset;
    while (number_of_tokens < 4096) {
        char c = text[offset];
        if (c == '\0') break;
        size_t whitespace_length = read_whitespace(text + offset, tokenizer->info);
        if (whitespace_length > 0) {
            whitespace += whitespace_length;
            offset += whitespace_length;
            continue;
        }
        uint32_t token = -1;
        CUSTOM_TOKEN_DATA(custom_data);
        uint64_t integer = 0;
        NUMBER_TOKEN_DATA(number);
        bool is_token = false;
        bool end_token = false;
        bool custom_token = false;
        bool comment = false;
        bool custom_whitespace = false;
        bool has_escapes = false;
        size_t token_length = read_keyword_token(&token, &end_token, text + offset, tokenizer->info);
        if (token_length > 0) {
            is_token = true;
            if (token == 4294967295U) comment = true;
        }
        if (IGNORE_TOKEN_READ(&token, &token_length, text + offset, &custom_whitespace, &custom_data, tokenizer->info)) {
            is_token = true;
            custom_token = true;
            end_token = false;
            comment = false;
        }
        IF_INTEGER_TOKEN(char_is_numeric(c), {
            size_t integer_offset = offset;
            uint64_t base = 10;
            if (c == '0' && (text[offset + 1] == 'x' || text[offset + 1] == 'X') && (char_is_numeric(text[offset + 2]) || char_is_hexadecimal_alpha(text[integer_offset + 2]))) {
                integer_offset = offset + 2;
                base = 16;
            }
            integer = 0;
            bool overflow = false;
            while (char_is_numeric(text[integer_offset]) || (base == 16 && char_is_hexadecimal_alpha(text[integer_offset]))) {
                uint64_t last = integer;
                integer *= base;
                uint64_t ch = text[integer_offset];
                if (ch >= '0' && ch <= '9') integer += ch - '0';
                else if (ch >= 'a' && ch <= 'f') integer += ch - 'a' + 0xa;
                else if (ch >= 'A' && ch <= 'F') integer += ch - 'A' + 0xA;
                if (integer < last) {
                    overflow = true;
                    break;
                }
                integer_offset++;
            }
            if (!overflow && integer_offset - offset > token_length) {
                token_length = integer_offset - offset;
                is_token = true;
                end_token = false;
                comment = false;
                custom_whitespace = false;
                token = 4294967295U;
            }
        }
        ) IF_NUMBER_TOKEN(char_is_numeric(c) || (c == '.' && char_is_numeric(text[offset + 1])), {
            const char *start = (const char *)text + offset;
            char *rest = 0;
            number = strtod(start, &rest);
            if (rest > start && rest - start > token_length) {
                token_length = rest - start;
                is_token = true;
                end_token = false;
                comment = false;
                custom_whitespace = false;
                token = 8;
            }
        }
        ) else IF_STRING_TOKEN(c == '\'' || c == '"', {
            size_t string_offset = offset + 1;
            while (text[string_offset] != '\0') {
                if (text[string_offset] == c) {
                    token_length = string_offset + 1 - offset;
                    is_token = true;
                    end_token = false;
                    comment = false;
                    custom_whitespace = false;
                    token = 4294967295U;
                    break;
                }
                if (text[string_offset] == '\\') {
                    has_escapes = true;
                    string_offset++;
                    if (text[string_offset] == '\0') break;
                }
                string_offset++;
            }
        }
        ) else IF_IDENTIFIER_TOKEN(char_starts_identifier(c), {
            size_t identifier_offset = offset + 1;
            while (char_continues_identifier(text[identifier_offset], tokenizer->info)) identifier_offset++;
            while (!char_ends_identifier(text[identifier_offset - 1])) identifier_offset--;
            if (identifier_offset - offset > token_length) {
                token_length = identifier_offset - offset;
                is_token = true;
                end_token = false;
                comment = false;
                custom_whitespace = false;
                token = 7;
            }
        }
        ) if (custom_whitespace) {
            whitespace += token_length;
            offset += token_length;
            continue;
        }
        else if (comment) {
            while (text[offset] != '\0' && text[offset] != '\n') {
                whitespace++;
                offset++;
            }
            continue;
        }
        else if (!is_token || token == 4294967295U) {
            tokenizer->offset = offset;
            tokenizer->whitespace = whitespace;
            free(run);
            return false;
        }
        if (end_token && number_of_tokens + 1 >= 4096) break;
        if (!encode_token_length(run, &lengths_size, token_length, whitespace)) break;
        if (token == 7) {
            write_identifier_token(offset, token_length, tokenizer->info);
        }
        else if (token == 4294967295U) {
            IGNORE_TOKEN_WRITE(offset, token_length, integer, tokenizer->info);
        }
        else if (token == 8) {
            write_number_token(offset, token_length, number, tokenizer->info);
        }
        else if (token == 4294967295U) {
            size_t content_offset = offset + 1;
            size_t content_length = token_length - 2;
            const char *string = text + content_offset;
            size_t string_length = content_length;
            if (has_escapes) {
                size_t i;
                for (i = 0;
                i < content_length;
                ++i) {
                    if (text[content_offset + i] == '\\') {
                        string_length--;
                        i++;
                    }
                }
                char *unescaped = allocate_string_contents(string_length, tokenizer->info);
                size_t j = 0;
                for (i = 0;
                i < content_length;
                ++i) {
                    if (text[content_offset + i] == '\\') i++;
                    unescaped[j++] = ESCAPE_CHAR(text[content_offset + i], tokenizer->info);
                }
                string = unescaped;
            }
            IGNORE_TOKEN_WRITE(offset, token_length, string, string_length, has_escapes, tokenizer->info);
        }
        else if (custom_token) {
            IGNORE_TOKEN_WRITE(offset, token_length, token, custom_data, tokenizer->info);
        }
        run->tokens[number_of_tokens] = token;
        whitespace = 0;
        number_of_tokens++;
        offset += token_length;
        if (end_token) {
            assert(number_of_tokens < 4096);
            run->tokens[number_of_tokens] = 4294967295U;
            number_of_tokens++;
        }
    }
    if (number_of_tokens == 0) {
        tokenizer->offset = offset;
        tokenizer->whitespace = whitespace;
        free(run);
        return false;
    }
    tokenizer->offset = offset;
    tokenizer->whitespace = whitespace;
    run->prev = *previous_run;
    run->number_of_tokens = number_of_tokens;
    run->lengths_size = lengths_size;
    *previous_run = run;
    return true;
}
static void find_token_range(struct owl_default_tokenizer *tokenizer, struct owl_token_run *run, uint16_t index, size_t *start, size_t *end) {
    size_t offset = tokenizer->offset - tokenizer->whitespace;
    size_t last_offset = offset;
    size_t len = 0;
    uint16_t length_offset = run->lengths_size - 1;
    uint16_t j;
    for (j = index;
    j < run->number_of_tokens;
    ++j) {
        if (run->tokens[j] == 4294967295U) continue;
        last_offset = offset;
        len = decode_token_length(run, &length_offset, &offset);
    }
    *start = last_offset - len;
    *end = last_offset;
}
static void estimate_next_token_range(struct owl_default_tokenizer *tokenizer, size_t *start, size_t *end) {
    *start = tokenizer->offset;
    size_t i = tokenizer->offset + 1;
    while (tokenizer->text[i] != '\0' && !char_is_whitespace(tokenizer->text[i]) && !char_continues_identifier(tokenizer->text[i], tokenizer->info)) i++;
    *end = i;
}
static void find_end_range(struct owl_default_tokenizer *tokenizer, size_t *start, size_t *end) {
    *start = tokenizer->offset - tokenizer->whitespace - 1;
    *end = tokenizer->offset - tokenizer->whitespace;
    if (*start > *end) {
        *start = *end;
        *end += 1;
    }
}
static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context);
static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context);
static size_t number_of_slots_lookup(uint32_t rule, void *context);
static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context);
enum construct_fixity_associativity {
CONSTRUCT_PREFIX, CONSTRUCT_POSTFIX, CONSTRUCT_INFIX_LEFT, CONSTRUCT_INFIX_RIGHT, CONSTRUCT_INFIX_FLAT, };
struct construct_node {
    struct construct_node *next;
    size_t number_of_slots;
    size_t *slots;
    uint32_t rule;
    uint16_t slot_index;
    uint16_t choice_index;
    enum construct_fixity_associativity fixity_associativity;
    int precedence;
    size_t start_location;
    size_t end_location;
};
struct construct_expression {
    struct construct_expression *parent;
    struct construct_node *first_operator;
    struct construct_node *first_value;
    uint32_t operand_slot_index;
    uint32_t left_slot_index;
    uint32_t right_slot_index;
    uint32_t rule;
    uint16_t slot_index;
};
enum construct_root_type {
CONSTRUCT_NORMAL_ROOT, CONSTRUCT_EXPRESSION_ROOT, };
struct construct_state {
    enum construct_root_type root_type;
    struct construct_node *under_construction;
    struct construct_expression *current_expression;
    struct construct_node *node_freelist;
    struct construct_expression *expression_freelist;
    void *info;
};
static struct construct_node *construct_node_alloc(struct construct_state *s, uint32_t rule) {
    struct construct_node *node;
    size_t number_of_slots = number_of_slots_lookup(rule, s->info);
    if (s->node_freelist) {
        node = s->node_freelist;
        s->node_freelist = node->next;
        size_t *slots = node->slots;
        if (number_of_slots > node->number_of_slots) {
            slots = realloc(slots, number_of_slots * sizeof(size_t));
            if (!slots) abort();
        }
        memset(node, 0, sizeof(struct construct_node));
        memset(slots, 0, number_of_slots * sizeof(size_t));
        node->slots = slots;
    }
    else {
        node = calloc(1, sizeof(struct construct_node));
        if (!node) abort();
        node->slots = calloc(number_of_slots, sizeof(size_t));
        if (number_of_slots > 0 && !node->slots) abort();
    }
    node->rule = rule;
    node->number_of_slots = number_of_slots;
    return node;
}
static struct construct_expression *construct_expression_alloc(struct construct_state *s, uint32_t rule) {
    struct construct_expression *expr;
    if (s->expression_freelist) {
        expr = s->expression_freelist;
        s->expression_freelist = expr->parent;
        memset(expr, 0, sizeof(struct construct_expression));
    }
    else {
        expr = calloc(1, sizeof(struct construct_expression));
        if (!expr) abort();
    }
    (left_right_operand_slots_lookup(rule, &(expr->left_slot_index), &(expr->right_slot_index), &(expr->operand_slot_index), s->info));
    expr->rule = rule;
    return expr;
}
static void construct_node_free(struct construct_state *state, struct construct_node *node) {
    node->next = state->node_freelist;
    state->node_freelist = node;
}
static void construct_expression_free(struct construct_state *state, struct construct_expression *expr) {
    expr->parent = state->expression_freelist;
    state->expression_freelist = expr;
}
static bool construct_expression_should_reduce(struct construct_state *s, struct construct_expression *expr, struct construct_node *node) {
    if (node->fixity_associativity == CONSTRUCT_POSTFIX) return false;
    struct construct_node *top = expr->first_operator;
    if (!top) return false;
    return node->precedence < top->precedence || (node->precedence == top->precedence && node->fixity_associativity == CONSTRUCT_INFIX_RIGHT);
}
static void construct_expression_reduce(struct construct_state *s, struct construct_expression *expr) {
    struct construct_node *op = expr->first_operator;
    if (op->fixity_associativity == CONSTRUCT_INFIX_FLAT) {
        struct construct_node *first_value = expr->first_value;
        struct construct_node *last_value = first_value;
        struct construct_node *last_operator = op;
        size_t operand = op->slots[expr->operand_slot_index];
        struct construct_node *combined_op = construct_node_alloc(s, op->rule);
        combined_op->choice_index = op->choice_index;
        combined_op->slot_index = op->slot_index;
        combined_op->fixity_associativity = op->fixity_associativity;
        combined_op->precedence = op->precedence;
        struct construct_node *reversed_values = 0;
        while (last_operator && last_operator->choice_index == op->choice_index) {
            struct construct_node *next_op = last_operator->next;
            construct_node_free(s, last_operator);
            last_operator = next_op;
            assert(last_value);
            struct construct_node *next_value = last_value->next;
            last_value->next = reversed_values;
            reversed_values = last_value;
            last_value = next_value;
        }
        combined_op->start_location = first_value->start_location;
        combined_op->end_location = last_value->end_location;
        assert(last_value);
        operand = (finish_node((last_value)->rule, (last_value)->choice_index, operand, (last_value)->slots, (last_value)->start_location, (last_value)->end_location, s->info));
        combined_op->next = last_value->next;
        construct_node_free(s, last_value);
        while (reversed_values) {
            operand = (finish_node((reversed_values)->rule, (reversed_values)->choice_index, operand, (reversed_values)->slots, (reversed_values)->start_location, (reversed_values)->end_location, s->info));
            struct construct_node *next_value = reversed_values->next;
            construct_node_free(s, reversed_values);
            reversed_values = next_value;
        }
        expr->first_operator = last_operator;
        expr->first_value = combined_op;
        combined_op->slots[expr->operand_slot_index] = operand;
    }
    else if (op->fixity_associativity == CONSTRUCT_INFIX_LEFT || op->fixity_associativity == CONSTRUCT_INFIX_RIGHT) {
        expr->first_operator = op->next;
        struct construct_node *left = expr->first_value;
        struct construct_node *right = left->next;
        op->next = right->next;
        expr->first_value = op;
        op->start_location = left->start_location;
        op->end_location = right->end_location;
        op->slots[expr->left_slot_index] = (finish_node((left)->rule, (left)->choice_index, op->slots[expr->left_slot_index], (left)->slots, (left)->start_location, (left)->end_location, s->info));
        op->slots[expr->right_slot_index] = (finish_node((right)->rule, (right)->choice_index, op->slots[expr->right_slot_index], (right)->slots, (right)->start_location, (right)->end_location, s->info));
        construct_node_free(s, left);
        construct_node_free(s, right);
    }
    else {
        expr->first_operator = op->next;
        struct construct_node *value = expr->first_value;
        op->next = value->next;
        expr->first_value = op;
        if (value->start_location < op->start_location) op->start_location = value->start_location;
        if (value->end_location > op->end_location) op->end_location = value->end_location;
        op->slots[expr->operand_slot_index] = (finish_node((value)->rule, (value)->choice_index, op->slots[expr->operand_slot_index], (value)->slots, (value)->start_location, (value)->end_location, s->info));
        construct_node_free(s, value);
    }
}
static void construct_begin(struct construct_state *s, size_t offset, enum construct_root_type type) {
    s->root_type = type;
    uint32_t r = 0;
    if (type == CONSTRUCT_EXPRESSION_ROOT) {
        struct construct_expression *expr = construct_expression_alloc(s, r);
        expr->parent = s->current_expression;
        s->current_expression = expr;
    }
    else {
        struct construct_node *node = construct_node_alloc(s, r);
        node->next = s->under_construction;
        node->end_location = offset;
        s->under_construction = node;
    }
}
static size_t construct_finish(struct construct_state *s, size_t offset) {
    size_t finished = 0;
    if (s->root_type == CONSTRUCT_EXPRESSION_ROOT) {
        struct construct_expression *expr = s->current_expression;
        s->current_expression = expr->parent;
        while (expr->first_operator) construct_expression_reduce(s, expr);
        struct construct_node *node = expr->first_value;
        if (node) {
            finished = (finish_node((node)->rule, (node)->choice_index, 0, (node)->slots, (node)->start_location, (node)->end_location, s->info));
            assert(node->next == 0);
            construct_node_free(s, node);
        }
        construct_expression_free(s, expr);
    }
    else {
        struct construct_node *node = s->under_construction;
        s->under_construction = node->next;
        node->start_location = offset;
        finished = (finish_node((node)->rule, (node)->choice_index, 0, (node)->slots, (node)->start_location, (node)->end_location, s->info));
        construct_node_free(s, node);
    }
    while (s->node_freelist) {
        struct construct_node *node = s->node_freelist;
        s->node_freelist = node->next;
        free(node->slots);
        free(node);
    }
    while (s->expression_freelist) {
        struct construct_expression *expr = s->expression_freelist;
        s->expression_freelist = expr->parent;
        free(expr);
    }
    return finished;
}
static void construct_action_apply(struct construct_state *s, uint16_t action, size_t offset) {
    switch ((((action) >> 12) & 0xf)) {
    case 8:
        {
            struct construct_node *node = construct_node_alloc(s, rule_lookup(s->under_construction->rule, ((action) & 0xfff), s->info));
            node->next = s->under_construction;
            node->slot_index = ((action) & 0xfff);
            node->end_location = offset;
            s->under_construction = node;
            break;
        }
    case 9:
        {
            struct construct_expression *expr = construct_expression_alloc(s, rule_lookup(s->under_construction->rule, ((action) & 0xfff), s->info));
            expr->parent = s->current_expression;
            s->current_expression = expr;
            expr->slot_index = ((action) & 0xfff);
            break;
        }
    case 1:
        {
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            size_t *finished;
            finished = &s->under_construction->slots[node->slot_index];
            *finished = (finish_node((node)->rule, (node)->choice_index, *finished, (node)->slots, (node)->start_location, (node)->end_location, s->info));
            construct_node_free(s, node);
            break;
        }
    case 2:
        {
            struct construct_expression *expr = s->current_expression;
            s->current_expression = expr->parent;
            while (expr->first_operator) construct_expression_reduce(s, expr);
            size_t *finished;
            finished = &s->under_construction->slots[expr->slot_index];
            struct construct_node *node = expr->first_value;
            if (node) {
                *finished = (finish_node((node)->rule, (node)->choice_index, *finished, (node)->slots, (node)->start_location, (node)->end_location, s->info));
                assert(node->next == 0);
                construct_node_free(s, node);
            }
            construct_expression_free(s, expr);
            break;
        }
    case 3:
        s->under_construction->choice_index = ((action) & 0xfff);
        break;
    case 4:
        {
            uint16_t slot = ((action) & 0xfff);
            size_t *finished = &s->under_construction->slots[slot];
            *finished = finish_token(rule_lookup(s->under_construction->rule, slot, s->info), *finished, s->info);
            break;
        }
    case 10:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = construct_node_alloc(s, expr->rule);
            node->choice_index = ((action) & 0xfff);
            node->end_location = offset;
            node->rule = expr->rule;
            node->next = s->under_construction;
            s->under_construction = node;
            break;
        }
    case 11:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = construct_node_alloc(s, expr->rule);
            node->choice_index = ((action) & 0xfff);
            node->end_location = offset;
            node->rule = expr->rule;
            enum construct_fixity_associativity fixity_associativity = 0;
            int precedence = 0;
            do {
                int local = 0;
                fixity_associativity_precedence_lookup(&local, &precedence, expr->rule, ((action) & 0xfff), s->info);
                fixity_associativity = local;
            }
            while (0);
            node->fixity_associativity = fixity_associativity;
            node->precedence = precedence;
            node->next = s->under_construction;
            s->under_construction = node;
            break;
        }
    case 5:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            node->next = expr->first_value;
            expr->first_value = node;
            break;
        }
    case 6:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            while (construct_expression_should_reduce(s, expr, node)) construct_expression_reduce(s, expr);
            node->next = expr->first_operator;
            expr->first_operator = node;
            if (node->fixity_associativity == CONSTRUCT_PREFIX) construct_expression_reduce(s, expr);
            break;
        }
    }
}

struct fill_run_continuation;
struct fill_run_state {
    uint32_t state;
    uint32_t reachability_mask[1];
    struct fill_run_continuation *cont;
};
struct fill_run_continuation {
    struct fill_run_state *stack;
    size_t top_index;
    size_t capacity;
    int error;
};
static void bracket_entry_state(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index, uint32_t mask0);
static void (*state_funcs[33])(struct owl_token_run *, struct fill_run_state *, uint16_t);
static void state_func_10(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(3 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 0: top->state = 11; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_0(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 3: top->state = 1; return;
    case 7: top->state = 2; return;
    case 8: top->state = 3; return;
    case 10: top->state = 4; return;
    default:
        bracket_entry_state(run, top, token_index, 1);
        return;
    }
}
static void state_func_31(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 3: top->state = 24; return;
    case 7: top->state = 25; return;
    case 8: top->state = 26; return;
    case 10: top->state = 27; return;
    default:
        bracket_entry_state(run, top, token_index, 1);
        return;
    }
}
static void state_func_22(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(3 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 3: top->state = 13; return;
    case 7: top->state = 14; return;
    case 8: top->state = 15; return;
    case 10: top->state = 16; return;
    default:
        bracket_entry_state(run, top, token_index, 1);
        return;
    }
}
static void state_func_11(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(3 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 12; return;
    case 3: top->state = 13; return;
    case 7: top->state = 14; return;
    case 8: top->state = 15; return;
    case 10: top->state = 16; return;
    default:
        bracket_entry_state(run, top, token_index, 1);
        return;
    }
}
static void state_func_3(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 3: top->state = 5; return;
    case 4: top->state = 6; return;
    case 5: top->state = 7; return;
    case 6: top->state = 8; return;
    case 10: top->state = 9; return;
    case 9: top->state = 9; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_12(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    if (top->cont->top_index == 0) {
        top->cont->error = 1;
        return;
    }
    top->cont->top_index--;
    top--;
    run->tokens[token_index] = 9;
    run->states[token_index] = top->state;
    state_funcs[top->state](run, top, token_index);
    return;
}
static void state_func_17(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    if (top->cont->top_index == 0) {
        top->cont->error = 1;
        return;
    }
    top->cont->top_index--;
    top--;
    run->tokens[token_index] = 10;
    run->states[token_index] = top->state;
    state_funcs[top->state](run, top, token_index);
    return;
}
static void state_func_32(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 12; return;
    case 2: top->state = 18; return;
    case 3: top->state = 28; return;
    case 4: top->state = 29; return;
    case 5: top->state = 30; return;
    case 6: top->state = 31; return;
    case 10: top->state = 32; return;
    case 9: top->state = 32; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_23(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(3 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 17; return;
    case 2: top->state = 18; return;
    case 3: top->state = 19; return;
    case 4: top->state = 20; return;
    case 5: top->state = 21; return;
    case 6: top->state = 22; return;
    case 10: top->state = 23; return;
    case 9: top->state = 23; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void (*state_funcs[33])(struct owl_token_run *, struct fill_run_state *, uint16_t) = {
    state_func_0, state_func_0, state_func_3, state_func_3,
    state_func_3, state_func_0, state_func_0, state_func_0,
    state_func_0, state_func_3, state_func_10, state_func_11,
    state_func_12, state_func_22, state_func_23, state_func_23,
    state_func_23, state_func_17, state_func_31, state_func_22,
    state_func_22, state_func_22, state_func_22, state_func_23,
    state_func_31, state_func_32, state_func_32, state_func_32,
    state_func_31, state_func_31, state_func_31, state_func_31,
    state_func_32,};
static void bracket_entry_state(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index, uint32_t mask0) {
    struct fill_run_continuation *cont = top->cont;
    cont->top_index++;
    if (cont->top_index >= cont->capacity) {
        size_t new_capacity = (cont->capacity + 2) * 3 / 2;
        if (new_capacity <= cont->capacity)
            abort();
        struct fill_run_state *new_states = realloc(cont->stack, new_capacity * sizeof(struct fill_run_state));
        if (!new_states)
            abort();
        cont->stack = new_states;
        cont->capacity = new_capacity;
        top = &cont->stack[cont->top_index];
    } else
        top++;
    top->cont = cont;
    top->reachability_mask[0] = mask0;
    run->states[token_index] = 10;
    state_func_10(run, top, token_index);
    if (top->cont->error == -1)
        top->cont->error = 1;
}
static bool fill_run_states(struct owl_token_run *run, struct fill_run_continuation *cont, uint16_t *failing_index);
static size_t build_parse_tree(struct owl_default_tokenizer *, struct owl_token_run *, struct owl_tree *);

static struct owl_tree *owl_tree_create_empty(void) {
    return calloc(1, sizeof(struct owl_tree));
}

static void free_token_runs(struct owl_token_run **run) {
    while (*run) {
        struct owl_token_run *prev = (*run)->prev;
        free(*run);
        *run = prev;
    }
}
static void parse_string(struct owl_tree *tree, const char *string) {
    tree->string = string;
    tree->next_offset = 1;
    struct owl_default_tokenizer tokenizer = {
        .text = string,
        .info = tree,
    };
    struct owl_token_run *token_run = 0;
    struct fill_run_continuation c = {
        .capacity = 8,
        .top_index = 0,
    };
    c.stack = calloc(c.capacity, sizeof(struct fill_run_state));
    c.stack[0].state = 0;
    c.stack[0].cont = &c;
    uint16_t failing_index = 0;
    while (owl_default_tokenizer_advance(&tokenizer, &token_run)) {
        if (!fill_run_states(token_run, &c, &failing_index)) {
            free(c.stack);
            tree->error = ERROR_UNEXPECTED_TOKEN;
            find_token_range(&tokenizer, token_run, failing_index, &tree->error_range.start, &tree->error_range.end);
            free_token_runs(&token_run);
            return;
        }
    }
    struct fill_run_state top = c.stack[c.top_index];
    free(c.stack);
    if (string[tokenizer.offset] != '\0') {
        tree->error = ERROR_INVALID_TOKEN;
        estimate_next_token_range(&tokenizer, &tree->error_range.start, &tree->error_range.end);
        free_token_runs(&token_run);
        return;
    }
    switch (top.state) {
    case 2:
    case 3:
    case 4:
    case 9:
        break;
    default:
        tree->error = ERROR_MORE_INPUT_NEEDED;
        find_end_range(&tokenizer, &tree->error_range.start, &tree->error_range.end);
        free_token_runs(&token_run);
        return;
    }
    tree->root_offset = build_parse_tree(&tokenizer, token_run, tree);
}
static struct owl_tree *owl_tree_create_with_error(enum owl_error e) {
    struct owl_tree *tree = owl_tree_create_empty();
    tree->error = e;
    return tree;
}
struct owl_tree *owl_tree_create_from_string(const char *string) {
    return owl_tree_create_with_options((struct owl_tree_options){ .string = string });
}
struct owl_tree *owl_tree_create_from_file(FILE *file) {
    if (!file)
        return owl_tree_create_with_error(ERROR_INVALID_FILE);
    return owl_tree_create_with_options((struct owl_tree_options){ .file = file });
}
struct owl_tree *owl_tree_create_with_options(struct owl_tree_options options) {
    if (!options.file == !options.string)
        return owl_tree_create_with_error(ERROR_INVALID_OPTIONS);
    if (options.file) {
        char *str = 0;
        size_t len = 32;
        size_t off = 0;
        while (true) {
            len = len * 3 / 2;
            char *s = realloc(str, len);
            if (!s) {
                free(str);
                return 0;
            }
            str = s;
            off += fread(str + off, 1, len - off, options.file);
            if (off < len) {
                str[off] = '\0';
                break;
            }
        }
        options.string = str;
    }
    struct owl_tree *tree = owl_tree_create_empty();
    if (options.file)
        tree->owns_string = true;
    parse_string(tree, options.string);
    return tree;
}
enum owl_error owl_tree_get_error(struct owl_tree *tree, struct source_range *error_range) {
    if (error_range)
        *error_range = tree->error_range;
    return tree->error;
}
void owl_tree_destroy(struct owl_tree *tree) {
    if (!tree)
        return;
    if (tree->owns_string)
        free((void *)tree->string);
    free(tree->parse_tree);
    free(tree);
}
static bool fill_run_states(struct owl_token_run *run, struct fill_run_continuation *cont, uint16_t *failing_index) {
    uint16_t token_index = 0;
    uint16_t number_of_tokens = run->number_of_tokens;
    while (token_index < number_of_tokens) {
        struct fill_run_state *top = &cont->stack[cont->top_index];
        run->states[token_index] = top->state;
        state_funcs[top->state](run, top, token_index);
        if (cont->error) {
            *failing_index = token_index - (cont->error > 0 ? 0 : 1);
            return false;
        }
        token_index++;
    }
    return true;
}
static const uint16_t actions[] = {
0,20480,0,20480,8192,0,20480,45060,0,20480,45061,0,20480,45062,0,20480,45063,0,20480,45064,0,24576,0,24576,8192,0,24576,40960,16384,0,
24576,40961,16385,0,24576,40962,0,24576,45059,0,24576,45060,0,24576,45061,0,24576,45062,0,24576,45063,0,24576,45064,0,36866,40960,16384,0,36866,
40961,16385,0,36866,40962,0,36866,45059,0,40960,16384,0,40961,16385,0,40962,0,45059,0,45060,0,45061,0,45062,0,45063,0,45064,0,};
static const uint8_t action_table[256][2][6] = {
{{151,87,0,45,0,0,},{57,9,1,46,9,0,},},{{49,198,1,57,69,0,},{44,150,2,151,162,25,},},{{46,135,2,151,162,28,},},{{49,7,2,57,72,0,},
{42,160,1,48,49,0,},},{{45,142,2,151,66,22,},},{{47,220,1,43,55,0,},},{{45,211,1,51,55,0,},},{{148,80,1,44,46,0,},{47,223,1,43,55,0,},},
{{104,66,1,46,83,0,},{51,151,1,44,15,0,},},{{59,200,0,59,40,0,},},{{47,154,2,151,66,24,},},{{57,3,1,46,9,0,},},{{104,68,1,46,83,0,},},
{{47,89,2,150,66,24,},},{{148,207,0,44,52,0,},{42,155,1,48,49,0,},},{{51,206,0,44,18,0,},{49,129,2,151,203,28,},},{{42,90,1,48,46,0,},},
{{46,6,2,57,30,0,},},{{45,79,2,150,66,22,},},{{0}},{{0}},{{49,68,2,150,77,23,},},{{150,90,0,47,0,0,},},{{104,2,1,46,81,0,},},{{43,160,1,48,15,0,},},
{{0}},{{59,255,3,104,21,52,},{45,87,2,150,66,22,},},{{57,73,1,46,12,0,},{43,25,1,48,9,0,},},{{57,4,1,46,9,0,},{43,144,0,45,3,0,},},
{{48,89,2,150,37,24,},},{{46,128,2,151,162,28,},},{{51,80,1,44,12,0,},{49,192,1,57,69,0,},},{{48,210,1,43,26,0,},},{{45,147,2,151,191,25,},},
{{148,208,0,44,52,0,},{104,130,1,46,85,0,},},{{59,194,0,46,52,0,},},{{47,29,2,43,59,0,},},{{48,28,2,43,30,0,},{47,90,2,150,66,24,},},
{{148,206,0,44,52,0,},{57,67,1,46,12,0,},},{{48,30,2,43,30,0,},{42,142,0,45,23,0,},},{{45,203,1,51,55,0,},{44,151,2,151,37,22,},},
{{42,91,1,48,46,0,},},{{49,6,2,57,72,0,},},{{148,87,1,44,46,0,},},{{42,153,1,48,49,0,},},{{59,4,1,46,43,0,},{45,143,2,151,66,22,},},
{{150,75,0,152,0,0,},},{{104,196,0,46,87,0,},{44,79,2,150,37,22,},},{{0}},{{148,211,0,148,40,0,},},{{59,195,0,46,52,0,},{43,154,1,48,15,0,},},
{{104,197,0,59,79,0,},{43,155,1,48,15,0,},},{{48,96,2,150,37,24,},{43,218,0,48,18,0,},},{{45,151,2,151,66,22,},},{{42,210,0,42,40,0,},},
{{57,196,0,46,18,0,},},{{104,3,1,46,81,0,},{46,7,2,57,30,0,},},{{49,135,2,151,203,28,},{42,144,0,45,23,0,},},{{48,216,1,43,26,0,},
{46,198,1,57,26,0,},},{{59,68,1,46,46,0,},},{{51,205,0,148,6,0,},{47,221,1,43,55,0,},},{{59,192,0,59,40,0,},},{{45,148,2,151,191,25,},
{44,78,2,150,37,22,},},{{151,80,0,45,0,0,},},{{57,130,1,46,15,0,},{46,66,2,150,37,23,},},{{57,131,1,46,15,0,},},{{47,24,2,43,59,0,},
{44,212,1,51,26,0,},},{{148,23,1,44,43,0,},{45,11,2,51,59,0,},},{{51,211,0,148,6,0,},{42,27,1,48,43,0,},},{{0}},{{57,197,0,59,6,0,},
{47,158,2,151,191,21,},},{{104,199,0,59,79,0,},{43,222,0,42,6,0,},},{{0}},{{45,205,1,51,55,0,},},{{0}},{{104,67,1,46,83,0,},},{{46,137,2,151,37,23,},},
{{48,160,2,151,37,24,},{43,90,1,48,12,0,},},{{42,143,0,45,23,0,},},{{148,14,1,44,43,0,},{57,201,0,46,18,0,},},{{59,193,0,59,40,0,},
{57,192,0,59,6,0,},},{{47,153,2,151,66,24,},{43,153,1,48,15,0,},},{{48,155,2,151,37,24,},},{{46,199,1,57,26,0,},{42,154,0,47,23,0,},},
{{0}},{{104,137,1,46,85,0,},{57,198,0,59,6,0,},},{{49,193,1,57,69,0,},{43,223,0,42,6,0,},},{{51,87,1,44,12,0,},},{{47,157,2,151,191,21,},},
{{44,142,2,151,37,22,},},{{44,214,1,51,26,0,},},{{44,213,1,51,26,0,},},{{51,208,0,44,18,0,},},{{48,158,2,151,162,21,},{44,203,1,51,26,0,},},
{{45,80,2,150,66,22,},},{{104,198,0,59,79,0,},{42,219,0,48,52,0,},},{{49,134,2,151,203,28,},{44,144,2,151,37,22,},},{{104,73,1,46,83,0,},
{48,152,2,151,162,21,},},{{59,132,1,46,49,0,},},{{148,10,0,154,23,0,},{46,134,2,151,162,28,},},{{57,199,0,59,6,0,},{49,199,1,57,69,0,},},
{{43,220,0,42,6,0,},},{{48,157,2,151,162,21,},{46,131,2,151,37,23,},},{{51,214,0,148,6,0,},{45,149,2,151,191,25,},},{{43,26,1,48,9,0,},},
{{43,27,1,48,9,0,},},{{148,78,1,44,46,0,},},{{49,133,2,151,203,28,},{45,141,2,151,191,25,},},{{59,201,0,46,52,0,},},{{0}},{{49,136,2,151,203,28,},
{42,218,0,48,52,0,},},{{51,143,1,44,15,0,},},{{51,144,1,44,15,0,},{48,220,1,43,26,0,},},{{46,197,1,57,26,0,},},{{51,207,0,44,18,0,},},
{{49,66,2,150,77,23,},{43,151,0,45,3,0,},},{{45,20,2,51,59,0,},{43,221,0,42,6,0,},},{{148,142,1,44,49,0,},},{{51,215,0,44,18,0,},
{45,22,2,51,59,0,},},{{0}},{{47,152,2,151,191,21,},{44,19,2,51,30,0,},},{{45,139,2,151,191,25,},{44,148,2,151,162,25,},},{{42,155,0,47,23,0,},},
{{47,30,2,43,59,0,},},{{148,151,1,44,49,0,},{104,9,1,46,81,0,},},{{42,217,0,48,52,0,},},{{48,153,2,151,37,24,},},{{48,91,2,150,37,24,},
{47,96,2,150,66,24,},},{{44,143,2,151,37,22,},},{{46,67,2,150,37,23,},},{{150,96,0,47,0,0,},{49,137,2,151,77,23,},},{{148,79,1,44,46,0,},},
{{43,91,1,48,12,0,},},{{51,212,0,148,6,0,},},{{0}},{{49,128,2,151,203,28,},},{{0}},{{148,203,0,148,40,0,},{42,160,0,47,23,0,},},{{0}},{{48,18,2,43,30,0,},},
{{44,147,2,151,162,25,},{42,216,0,42,40,0,},},{{0}},{{48,90,2,150,37,24,},{46,68,2,150,37,23,},},{{57,68,1,46,12,0,},{48,221,1,43,26,0,},},
{{0}},{{59,137,1,46,49,0,},{43,224,0,48,18,0,},},{{49,132,2,151,77,23,},{47,146,2,151,191,21,},},{{47,216,1,43,55,0,},{43,142,0,45,3,0,},},
{{51,213,0,148,6,0,},},{{48,24,2,43,30,0,},},{{44,149,2,151,162,25,},},{{104,201,0,46,87,0,},{47,159,2,151,191,21,},},{{42,153,0,47,23,0,},},
{{59,199,0,59,40,0,},},{{46,5,2,57,30,0,},},{{47,28,2,43,59,0,},},{{104,131,1,46,85,0,},{48,29,2,43,30,0,},},{{47,155,2,151,66,24,},
{45,21,2,51,59,0,},},{{148,15,1,44,43,0,},},{{46,8,2,57,30,0,},{43,155,0,47,3,0,},},{{45,13,2,51,59,0,},},{{49,5,2,57,72,0,},},
{{59,131,1,46,49,0,},{46,192,1,57,26,0,},},{{152,10,0,154,0,0,},{47,160,2,151,66,24,},},{{49,8,2,57,72,0,},{42,224,0,48,52,0,},},
{{51,15,1,44,9,0,},},{{104,200,0,59,79,0,},{42,151,0,45,23,0,},},{{0}},{{0}},{{48,154,2,151,37,24,},{46,132,2,151,37,23,},},{{59,130,1,46,49,0,},
{57,193,0,59,6,0,},},{{51,16,1,44,9,0,},{43,143,0,45,3,0,},},{{45,150,2,151,191,25,},{43,160,0,47,3,0,},},{{48,223,1,43,26,0,},
{46,193,1,57,26,0,},},{{44,11,2,51,30,0,},},{{148,213,0,148,40,0,},{44,80,2,150,37,22,},},{{0}},{{59,196,0,46,52,0,},},{{44,141,2,151,162,25,},},
{{57,66,1,46,12,0,},{45,78,2,150,66,22,},},{{59,9,1,46,43,0,},},{{49,1,2,57,72,0,},{44,211,1,51,26,0,},},{{0}},{{45,212,1,51,55,0,},},
{{148,144,1,44,49,0,},},{{57,194,0,46,18,0,},{46,200,1,57,26,0,},},{{43,219,0,48,18,0,},},{{104,132,1,46,85,0,},{104,195,0,46,87,0,},},
{{49,0,2,57,72,0,},},{{43,153,0,47,3,0,},},{{148,212,0,148,40,0,},{51,142,1,44,15,0,},},{{59,198,0,59,40,0,},{42,154,1,48,49,0,},},
{{51,79,1,44,12,0,},{49,200,1,57,69,0,},},{{48,146,2,151,162,21,},},{{0}},{{42,223,0,42,40,0,},},{{51,10,0,154,3,0,},{49,130,2,151,77,23,},},
{{150,89,0,47,0,0,},{59,66,1,46,46,0,},},{{59,2,1,46,43,0,},{43,154,0,47,3,0,},},{{43,96,1,48,12,0,},},{{57,195,0,46,18,0,},
{47,18,2,43,59,0,},},{{44,20,2,51,30,0,},{43,216,0,42,6,0,},},{{49,197,1,57,69,0,},},{{44,22,2,51,30,0,},{44,21,2,51,30,0,},},
{{57,137,1,46,15,0,},},{{148,215,0,44,52,0,},{47,31,2,43,59,0,},},{{59,73,1,46,46,0,},{57,2,1,46,9,0,},},{{104,193,0,59,79,0,},
{42,32,1,48,43,0,},},{{46,133,2,151,162,28,},},{{148,16,1,44,43,0,},{49,73,2,150,77,23,},},{{49,67,2,150,77,23,},{42,222,0,42,40,0,},},
{{57,200,0,59,6,0,},},{{148,143,1,44,49,0,},},{{46,136,2,151,162,28,},{45,214,1,51,55,0,},},{{59,3,1,46,43,0,},},{{44,87,2,150,37,22,},},
{{43,217,0,48,18,0,},},{{51,78,1,44,12,0,},},{{45,144,2,151,66,22,},{42,96,1,48,46,0,},},{{151,78,0,45,0,0,},{42,89,1,48,46,0,},},
{{148,214,0,148,40,0,},{47,156,2,151,191,21,},},{{43,89,1,48,12,0,},},{{104,192,0,59,79,0,},{48,159,2,151,162,21,},},{{148,205,0,148,40,0,},},
{{57,255,3,104,1,52,},{46,129,2,151,162,28,},},{{42,221,0,42,40,0,},},{{43,32,1,48,9,0,},},{{47,210,1,43,55,0,},{43,210,0,42,6,0,},},
{{48,222,1,43,26,0,},{44,139,2,151,162,25,},},{{0}},{{57,132,1,46,15,0,},},{{47,222,1,43,55,0,},},{{44,13,2,51,30,0,},},{{46,0,2,57,30,0,},},
{{0}},{{45,19,2,51,59,0,},},{{59,197,0,59,40,0,},{47,91,2,150,66,24,},},{{104,255,3,104,0,52,},{49,131,2,151,77,23,},},{{45,213,1,51,55,0,},},
{{48,156,2,151,162,21,},{46,130,2,151,37,23,},},{{42,220,0,42,40,0,},},{{104,4,1,46,81,0,},},{{154,201,3,154,0,52,},},{{151,79,0,45,0,0,},},
{{51,14,1,44,9,0,},},{{42,26,1,48,43,0,},},{{42,25,1,48,43,0,},},{{0}},{{0}},{{44,205,1,51,26,0,},},{{0}},{{46,73,2,150,37,23,},},{{104,194,0,46,87,0,},
{59,67,1,46,46,0,},},{{51,23,1,44,9,0,},{51,203,0,148,6,0,},},{{48,31,2,43,30,0,},{46,1,2,57,30,0,},},{{150,91,0,47,0,0,},},
};

struct action_table_key {
    uint8_t bytes[3];
};
static inline struct action_table_key encode_key(uint32_t target_nfa_state, uint32_t dfa_state, uint32_t dfa_symbol) {
    struct action_table_key key = {{0}};
    key.bytes[0] |= (target_nfa_state >> 0) & 255;
    key.bytes[1] |= (dfa_state >> 0) & 63;
    key.bytes[1] |= (dfa_symbol << 6) & 255;
    key.bytes[2] |= (dfa_symbol >> 2) & 3;
    return key;
}
struct action_table_entry {
    uint32_t nfa_state;
    uint32_t actions;
    uint32_t push_nfa_state;
};
static struct action_table_entry decode_entry(const uint8_t *bytes) {
    struct action_table_entry entry = {0};
    entry.nfa_state |= ((uint32_t)bytes[3] & 255) << 0;
    entry.actions |= ((uint32_t)bytes[4] & 127) << 0;
    entry.push_nfa_state |= ((uint32_t)bytes[4] & 255) >> 7;
    entry.push_nfa_state |= ((uint32_t)bytes[5] & 127) << 1;
    return entry;
}
static struct action_table_entry action_table_lookup(uint32_t nfa_state, uint32_t dfa_state, uint32_t token) {
    uint32_t hash = ((((((0xe5aa55e5 ^ (nfa_state)) * 0xe5aa55e5) ^ (dfa_state)) * 0xe5aa55e5) ^ (token)) * 0xe5aa55e5);
    uint32_t index1 = hash & 255;
    uint32_t index2 = hash >> 24;
    struct action_table_key key = encode_key(nfa_state, dfa_state, token);
    uint32_t j = 0;
    const uint8_t *entry = 0;
    for (; j < 2; ++j) {
        entry = action_table[index1][j];
        if (!memcmp(key.bytes, entry, sizeof(key.bytes)))
            break;
        entry = action_table[index2][j];
        if (!memcmp(key.bytes, entry, sizeof(key.bytes)))
            break;
    }
    if (j >= 2)
        abort();
    return decode_entry(entry);
}
static void apply_actions(struct construct_state *state, uint32_t index, size_t start, size_t end) {
    size_t offset = end;
    uint32_t i;
    for (i = index; actions[i]; ++i) {
        if (((((actions[i]) >> 12) & 0xf) & 8))
            offset = start;
        construct_action_apply(state, actions[i], offset);
    }
}
static size_t build_parse_tree(struct owl_default_tokenizer *tokenizer, struct owl_token_run *run, struct owl_tree *tree) {
    struct construct_state construct_state = { .info = tree };
    uint32_t *state_stack = 0;
    uint32_t stack_depth = 0;
    size_t stack_capacity = 0;
    size_t whitespace = tokenizer->whitespace;
    size_t offset = tokenizer->offset - whitespace;
    construct_begin(&construct_state, offset, CONSTRUCT_EXPRESSION_ROOT);
    uint32_t nfa_state = 49;
    while (run) {
        uint16_t length_offset = run->lengths_size - 1;
        uint16_t n = run->number_of_tokens;
        uint16_t i;
        for (i = n - 1; i < n; i--) {
            size_t end = offset;
            size_t len = 0;
            struct action_table_entry entry = action_table_lookup(nfa_state, run->states[i], run->tokens[i]);
            if (run->tokens[i] < 9)
                len = decode_token_length(run, &length_offset, &offset);
            else {
                if (stack_depth >= stack_capacity) {
                    size_t new_capacity = (stack_capacity + 2) * 3 / 2;
                    if (new_capacity <= stack_capacity)
                        abort();
                    uint32_t *new_stack = realloc(state_stack, new_capacity * sizeof(uint32_t));
                    if (!new_stack)
                        abort();
                    state_stack = new_stack;
                    stack_capacity = new_capacity;
                }
                state_stack[stack_depth++] = entry.push_nfa_state;
            }
            apply_actions(&construct_state, entry.actions, end, end + whitespace);
            if (run->states[i] == 10) {
                if (stack_depth == 0)
                    abort();
                nfa_state = state_stack[--stack_depth];
            } else
                nfa_state = entry.nfa_state;
            whitespace = end - offset - len;
        }
        struct owl_token_run *old = run;
        run = run->prev;
        free(old);
    }
    struct action_table_entry entry = action_table_lookup(nfa_state, UINT32_MAX, UINT32_MAX);
    apply_actions(&construct_state, entry.actions, offset, offset + whitespace);
    free(state_stack);
    free_token_runs(&run);
    return construct_finish(&construct_state, offset);
}
static size_t read_whitespace(const char *text, void *info) {
    switch (text[0]) {
    case 32:
        return 1;
    case 9:
        return 1;
    case 10:
        return 1;
    case 13:
        return 1;
    default:
        return 0;
    }
}
static size_t read_keyword_token(uint32_t *token, bool *end_token, const char *text, void *info) {
    switch (text[0]) {
    case 40:
        *end_token = false;
        *token = 0;
        return 1;
    case 41:
        *end_token = true;
        *token = 1;
        return 1;
    case 42:
        *end_token = false;
        *token = 4;
        return 1;
    case 43:
        *end_token = false;
        *token = 6;
        return 1;
    case 44:
        *end_token = false;
        *token = 2;
        return 1;
    case 45:
        *end_token = false;
        *token = 3;
        return 1;
    case 47:
        *end_token = false;
        *token = 5;
        return 1;
    default:
        return 0;
    }
}
static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context) {
    switch (parent) {
    case 0:
        switch (slot) {
        case 0: return 1;
        case 1: return 2;
        case 2: return 0;
        case 3: return 0;
        case 4: return 0;
        case 5: return 0;
        default: break;
        }
        break;
    default: break;
    }
    return UINT32_MAX;
}
static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context) {
    switch (rule) {
    case 0:
        switch (choice) {
        case 3:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 4:
            *precedence = -2;
            *fixity_associativity = CONSTRUCT_PREFIX;
            return;
        case 5:
            *precedence = -3;
            *fixity_associativity = CONSTRUCT_INFIX_LEFT;
            return;
        case 6:
            *precedence = -3;
            *fixity_associativity = CONSTRUCT_INFIX_LEFT;
            return;
        case 7:
            *precedence = -4;
            *fixity_associativity = CONSTRUCT_INFIX_LEFT;
            return;
        case 8:
            *precedence = -4;
            *fixity_associativity = CONSTRUCT_INFIX_LEFT;
            return;
        default: return;
        }
    default: return;
    }
}
static size_t number_of_slots_lookup(uint32_t rule, void *context) {
    switch (rule) {
    case 0: return 6;
    case 1: return 0;
    case 2: return 0;
    default: return 0;
    }
}
static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context) {
    switch (rule) {
    case 0:
        *left = 4;
        *right = 5;
        *operand = 3;
        break;
    case 1:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 2:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    }
}
#endif

